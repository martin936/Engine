#version 450
#extension GL_EXT_samplerless_texture_functions : require

layout(binding = 0) uniform utexture3D	LightListPtr;

layout(binding = 1, std430) readonly buffer buf1
{
	uint	dummy;
	uint	LightIndices[];
};

layout(binding = 2) uniform texture2D			ZBuffer;
layout(binding = 3) uniform texture2D			SunShadowMap;
layout(binding = 4) uniform samplerShadow       sampShadow;
layout(binding = 5) uniform sampler             sampLinear;

layout(binding = 6, r8)	uniform restrict writeonly	image2DArray	FilterShadows;


layout (binding = 7, std140) uniform cb7
{
	mat4	m_View;
	mat4	m_Proj;
	mat4	m_ViewProj;
	mat4	m_InvView;
	mat4	m_InvViewProj;

	mat4	m_LastView;
	mat4	m_LastProj;
	mat4	m_LastViewProj;
	mat4	m_LastInvView;
	mat4	m_LastInvViewProj;

	vec4	m_Eye;
};


layout(push_constant) uniform pc0
{
	mat4    ShadowMatrix;  
	uvec2   size;
    uvec2   shadowSize;  
    float   Near;
    float   Far;
    uint    NumSlices;
};



float ComputePCSSFilterSizeOrtho(vec2 texcoord, float depth)
{    
    uvec2 pixelCoord = uvec2(texcoord * shadowSize - 0.5f);
    
    vec2 sampleCoord;
    vec4 sampleDepth;
    float meanDepth = 0.f;
    float w = 0.f;
    
    const vec2 offsets[] =
    {
        vec2(1.5f, 1.5f),
        vec2(1.5f, -1.5f),
        vec2(-1.5f, -1.5f),
        vec2(-1.5f, 1.5f),
        vec2(-1.5f, 0.f),
        vec2(1.5f, 0.f),
        vec2(0.f, 1.5f),
        vec2(0.f, -1.5f),
    };
    
    depth = Far - depth * (Far - Near);
    
    for (int i = 0; i < 8; i++)
    {
        sampleCoord = (pixelCoord + offsets[i] + 0.5f) / shadowSize;        
        
        sampleDepth = textureGather(sampler2D(SunShadowMap, sampLinear), sampleCoord);
        sampleDepth = Far - sampleDepth * (Far - Near);
        
        w += dot(1.f.xxxx, step(depth.xxxx, sampleDepth));
        meanDepth += dot(1.f.xxxx, sampleDepth * step(depth.xxxx, sampleDepth));
    }
    
    meanDepth /= max(1e-6f, w);
    
    return meanDepth == 0.f ? 0.f : (depth - meanDepth) / meanDepth;
}


float InterleavedGradientNoise(vec2 pixcoords)
{
    return fract(52.9829189 * fract(0.06711056 * pixcoords.x + 0.00583715 * pixcoords.y));
}


float FilterShadowMapPCF(vec2 texcoord, vec2 pixcoords, float depth, float radius)
{
    uint i = 0;
    float light = 0.f;

    float a = InterleavedGradientNoise(pixcoords);
    float c = cos(a);
    float s = sin(a);

    mat2 rot = mat2(c, s, -s, c);

    const vec2 offsets[8] =
    {
        vec2(-0.0640593f, 0.164762f),
		vec2(0.274582f, -0.135479f),
		vec2(-0.379531f, -0.110482f),
		vec2(0.242826f, 0.399732f),
		vec2(0.10314f, -0.520204),
		vec2(-0.472558f, 0.347044f),
		vec2(0.633651f, 0.0688226f),
		vec2(-0.451954f, -0.514283f),
    };

    for (i = 0; i < 8; i++)
    {
        vec2 offset;

        offset = radius * offsets[i].xy;
        offset = rot * offset;

        light += texture(sampler2DShadow(SunShadowMap, sampShadow), vec3(texcoord + offset, depth));
    }

    return light * (1.f / 8.f);
    //return depth * 10.f;
}




float GetSunShadowPCSS(in vec4 pos, in float fZDist, in vec2 pixcoords)
{
    float lit_factor = 0;

    bool success = false;

    vec2 DemiInvMapSize = 1.f / shadowSize;
    
    vec4 PosProj = ShadowMatrix * pos;
    
    PosProj /= PosProj.w;
    PosProj.xy = PosProj.xy * 0.5f + 0.5f;
    PosProj.y = 1.0 - PosProj.y;

    PosProj.z = clamp(PosProj.z, 0.f, 1.f);

    if (PosProj.x < 0.f || PosProj.x > 1.f || PosProj.y < 0.f || PosProj.y > 1.f)
        lit_factor = 1.f;
    else
        success = true;
    
    if (success)
    {
        float radius = 2.f;//ComputePCSSFilterSizeOrtho(PosProj.xy, PosProj.z);
        //radius = clamp(radius, 0.f, 1.f);            
        //radius = clamp(radius * 10.f, 1.f, 8.f);
            
        lit_factor = FilterShadowMapPCF(PosProj.xy, pixcoords, PosProj.z, radius * DemiInvMapSize.x);
    }

    return lit_factor;
}



layout (local_size_x = 16, local_size_y = 16, local_size_z = 1) in;
void main(void)
{
	uint threadIndex = gl_LocalInvocationIndex;
    
    if (gl_GlobalInvocationID.x < size.x && gl_GlobalInvocationID.y < size.y)
    {
        vec2 proj_coord = (gl_GlobalInvocationID.xy + 0.5f) / size;
        proj_coord.y = 1.f - proj_coord.y;
	
	    //---------- UNPACK DEPTH
        float depth     = texelFetch(ZBuffer, ivec2(gl_GlobalInvocationID.xy), 0).r;
	    //---------- UNPACK POS
        vec4 projPos    = vec4(proj_coord.xy * 2.0f - 1.0f, depth, 1.0f);
        vec4 pos        = m_InvViewProj * projPos;
        pos /= pos.w;
        
        if (depth == 0.f)
            return;
            
        float shadow = GetSunShadowPCSS(pos, depth, gl_GlobalInvocationID.xy + 0.5f);

        imageStore(FilterShadows, ivec3(gl_GlobalInvocationID.xy, NumSlices - 1), shadow.xxxx);
    }
}
