#version 450
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : require

layout (binding = 0) uniform texture2D	NormalDepth;
layout (binding = 1) uniform texture2D	LastNormalDepth;
layout (binding = 2) uniform texture2D	DepthMap;
layout (binding = 3) uniform texture2D	LastDepthMap;
layout (binding = 4) uniform texture2D	MotionVectors;
layout (binding = 5) uniform texture2D	ChromaHistory;
layout (binding = 6) uniform texture2D	LumaHistory;
layout (binding = 7) uniform texture2D	MomentsHistory;
layout (binding = 8) uniform texture2D	NoisyChroma;
layout (binding = 9) uniform texture2D	NoisyLumaSH;

layout (binding = 10, rgba16f)	uniform restrict image2D NextChroma;
layout (binding = 11, rgba16f)	uniform restrict image2D NextLuma;
layout (binding = 12, rgba16f)	uniform restrict image2D NextMoments;


#define gAlpha          0.02f
#define gMomentsAlpha   0.2f


layout(push_constant) uniform pc0
{
    mat4    InvViewProj;
    mat4    LastInvViewProj;
    float   Near;
    float   Far;
};


float Luminance(vec3 rgb)
{
	return dot(rgb, vec3(0.299f, 0.587f, 0.114f));
}


// Returns ±1
vec2 signNotZero(vec2 v)
{
	return vec2((v.x >= 0.0) ? +1.0 : -1.0, (v.y >= 0.0) ? +1.0 : -1.0);
}

vec3 DecodeOct(in vec2 e)
{
	e = e * 2.f - 1.f;
	vec3 v = vec3(e.xy, 1.0 - abs(e.x) - abs(e.y));
	if (v.z < 0) v.xy = (1.0 - abs(v.yx)) * signNotZero(v.xy);
	return normalize(v);
}


bool isReprjValid(ivec2 coord, vec3 worldPos, vec3 lastWorldPos, vec3 normal, vec3 normalPrev, float Z)
{
    const ivec2 imageDim = textureSize(LumaHistory, 0);

    // check whether reprojected pixel is inside of the screen
    if(any(lessThan(coord, ivec2(1,1))) || any(greaterThan(coord, imageDim - ivec2(1,1)))) 
        return false;

    if(dot(normal, normalPrev) < 0.f) 
        return false;

    vec3 posDiff = worldPos - lastWorldPos;
    float planeDist1 = abs(dot(posDiff, normalPrev));
    float planeDist2 = abs(dot(posDiff, normal));
    float maxPlaneDist = max(planeDist1, planeDist2);

    return (maxPlaneDist / Z) < 0.1f;
}


bool loadPrevData(vec2 fragCoord, out vec3 prevChroma, out vec4 prevLuma, out vec2 prevMoments, out float historyLength)
{
    const ivec2 ipos = ivec2(fragCoord);
    const vec2 imageDim = vec2(textureSize(LumaHistory, 0));

	vec2 motion = texelFetch(MotionVectors, ipos, 0).xy; 
    motion *= abs(motion);

    // +0.5 to account for texel center offset
    const ivec2 iposPrev = ivec2(vec2(ipos) - motion.xy * imageDim * vec2(1, -1) + vec2(0.5,0.5));

	vec4 depth  = texelFetch(NormalDepth, ipos, 0);
    depth.w     = texelFetch(DepthMap, ipos, 0).x;
    depth.w     = 2.f * Far * Near / (Near + Far - (2.f * depth.w - 1.f) * (Near - Far));
    vec3 normal = DecodeOct(depth.xy);

    vec2 Texcoords = (fragCoord + 0.5f) / imageDim;
	Texcoords.y = 1.f - Texcoords.y;

	vec4 pos = InvViewProj * vec4(Texcoords.xy * vec2(2.f, 2.f) - vec2(1.f, 1.f), depth.w, 1.f);
    vec3 worldPos = pos.xyz / pos.w;

    bool v[4];
	const vec2 posPrev = floor(fragCoord.xy) - motion.xy * imageDim;
    ivec2 offset[4] = { ivec2(0, 0), ivec2(1, 0), ivec2(0, 1), ivec2(1, 1) };

    prevChroma = 0.f.xxx;
    prevLuma = 0.f.xxxx;
    prevMoments = 0.f.xx;
    historyLength = 0.f;
    
    // check for all 4 taps of the bilinear filter for validity
	bool valid = false;
    for (int sampleIdx = 0; sampleIdx < 4; sampleIdx++)
    { 
        ivec2 loc           = ivec2(posPrev) + offset[sampleIdx];
        vec4 depthPrev      = texelFetch(LastNormalDepth, loc, 0);
        depthPrev.w         = texelFetch(LastDepthMap, loc, 0).x;
        depthPrev.w         = 2.f * Far * Near / (Near + Far - (2.f * depthPrev.w - 1.f) * (Near - Far));
        vec3 normalPrev     = DecodeOct(depthPrev.xy);

        Texcoords           = (loc + 0.5f) / imageDim;
	    Texcoords.y         = 1.f - Texcoords.y;

	    pos                 = LastInvViewProj * vec4(Texcoords.xy * vec2(2.f, 2.f) - vec2(1.f, 1.f), depthPrev.w, 1.f);
        pos.xyz /= pos.w;

        v[sampleIdx] = isReprjValid(iposPrev, worldPos, pos.xyz, normal, normalPrev, depth.w);

        valid = valid || v[sampleIdx];
    }    

    if (valid) 
    {
        float sumw = 0;
        float x = fract(posPrev.x);
        float y = fract(posPrev.y);

        // bilinear weights
        float w[4] = { (1 - x) * (1 - y), 
                            x  * (1 - y), 
                       (1 - x) *      y,
                            x  *      y };

        prevChroma  = vec3(0,0,0);
        prevLuma    = vec4(0,0,0,0);
        prevMoments = vec2(0,0);

        // perform the actual bilinear interpolation
        for (int sampleIdx = 0; sampleIdx < 4; sampleIdx++)
        {
            ivec2 loc = ivec2(posPrev) + offset[sampleIdx];            
            if (v[sampleIdx])
            {
                prevChroma  += w[sampleIdx] * texelFetch(ChromaHistory, loc, 0).rgb;
                prevLuma    += w[sampleIdx] * texelFetch(LumaHistory, loc, 0).rgba;
                prevMoments += w[sampleIdx] * texelFetch(MomentsHistory, loc, 0).xy;
                sumw        += w[sampleIdx];
            }
        }

		// redistribute weights in case not all taps were used
		valid = (sumw >= 0.01);
		prevChroma  = valid ? prevChroma / sumw   : vec3(0, 0, 0);
		prevLuma    = valid ? prevLuma / sumw   : vec4(0, 0, 0, 0);
		prevMoments = valid ? prevMoments / sumw  : vec2(0, 0);
    }

    if(!valid) // perform cross-bilateral filter in the hope to find some suitable samples somewhere
    {
        float cnt = 0.0;

        // this code performs a binary descision for each tap of the cross-bilateral filter
        const int radius = 1;
        for (int yy = -radius; yy <= radius; yy++)
        {
            for (int xx = -radius; xx <= radius; xx++)
            {
                ivec2 p = iposPrev + ivec2(xx, yy);
                vec4 depthPrev      = texelFetch(LastNormalDepth, ipos, 0);
                depthPrev.w         = texelFetch(LastDepthMap, ipos, 0).x;
                depthPrev.w         = 2.f * Far * Near / (Near + Far - (2.f * depthPrev.w - 1.f) * (Near - Far));
                vec3 normalPrev     = DecodeOct(depthPrev.xy);

                Texcoords           = (ipos + 0.5f) / imageDim;
	            Texcoords.y         = 1.f - Texcoords.y;

	            pos                 = LastInvViewProj * vec4(Texcoords.xy * vec2(2.f, 2.f) - vec2(1.f, 1.f), depthPrev.w, 1.f);
                pos.xyz /= pos.w;

                if ( isReprjValid(iposPrev, worldPos, pos.xyz, normal, normalPrev, depth.w) )
                {
					prevChroma  += texelFetch(ChromaHistory, p, 0).rgb;
					prevLuma    += texelFetch(LumaHistory, p, 0).rgba;
					prevMoments += texelFetch(MomentsHistory, p, 0).xy;
                    cnt += 1.0;
                }
            }
        }
        if (cnt > 0)
        {
            valid = true;
            prevChroma      /= cnt;
            prevLuma        /= cnt;
            prevMoments     /= cnt;
        }

    }

    if (valid)
    {
        // crude, fixme
        historyLength = texelFetch(MomentsHistory, iposPrev, 0).b;
    }
    else
    {
        prevChroma = vec3(0,0,0);
        prevLuma = vec4(0,0,0,0);
        prevMoments = vec2(0,0);
        historyLength = 0;
    }

    return valid;
}



layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in; 
void main() 
{
    ivec2 size = textureSize(LumaHistory, 0).xy;

    if (gl_GlobalInvocationID.x < size.x && gl_GlobalInvocationID.y < size.y)
    {
	    vec3 chroma = texelFetch(NoisyChroma, ivec2(gl_GlobalInvocationID.xy), 0).rgb;
	    vec4 luma   = texelFetch(NoisyLumaSH, ivec2(gl_GlobalInvocationID.xy), 0).rgba;

        vec3 prevChroma;
        vec4 prevLuma;
        vec2 prevMoments;
        float historyLength;

        bool success = loadPrevData(gl_GlobalInvocationID.xy, prevChroma, prevLuma, prevMoments, historyLength);
        historyLength = min( 32.0f, success ? historyLength + 1.0f : 1.0f );

        // this adjusts the alpha for the case where insufficient history is available.
        // It boosts the temporal accumulation to give the samples equal weights in
        // the beginning.
        const float alpha        = success ? max(gAlpha,        1.0 / historyLength) : 1.0;
        const float alphaMoments = success ? max(gMomentsAlpha, 1.0 / historyLength) : 1.0;

        // compute first two moments of luminance
        vec2 moments;
        moments.r = luma.x;
        moments.g = moments.r * moments.r;

        // temporal integration of the moments
        moments = mix(prevMoments, moments, alphaMoments);

        float variance = max(0.f, moments.g - moments.r * moments.r);

        chroma = mix(prevChroma * prevLuma.x, chroma * luma.x, alpha);
        chroma /= max(1e-8f, Luminance(chroma.rgb));

        imageStore(NextChroma,  ivec2(gl_GlobalInvocationID.xy),    vec4(chroma, 0));
        imageStore(NextLuma,    ivec2(gl_GlobalInvocationID.xy),    mix(prevLuma, luma, alpha));
        imageStore(NextMoments, ivec2(gl_GlobalInvocationID.xy),    vec4(mix(prevMoments, moments, alpha), historyLength, variance));
    }
}
