#version 450
#extension GL_EXT_samplerless_texture_functions : require
#extension GL_GOOGLE_include_directive : require

#include "../../Lights/GLSL/Lighting.glsl"


layout (binding = 21, std140) uniform cb21
{
	mat4	m_View;
	mat4	m_Proj;
	mat4	m_ViewProj;
	mat4	m_InvView;
	mat4	m_InvViewProj;

	mat4	m_LastView;
	mat4	m_LastProj;
	mat4	m_LastViewProj;
	mat4	m_LastInvView;
	mat4	m_LastInvViewProj;

	vec4	m_Eye;
	vec4	m_CameraOffset;
};


layout(binding = 22, std140) uniform cb22
{
	vec4 m_Offsets[4];
};


layout(push_constant) uniform pc0
{
	vec4 Center0;
	vec4 Size0;
	vec4 Center1;
	vec4 Size1;
	vec4 Center2;
	vec4 Size2;
	vec4 RealCenter;

	float Near;
	float Far;
	float MaxRayLength;
	float TemporalOffset;
};


layout(binding = 0) uniform texture2D			DepthMap;
layout(binding = 1) uniform texture2D			HiZ;
layout(binding = 2) uniform texture2D			Radiance;
layout(binding = 3) uniform texture2D			NormalMap;

layout(binding = 4) uniform texture2DArray		IrradianceSHFine;
layout(binding = 5) uniform itexture2DArray		ProbeMetadataFine;
layout(binding = 6) uniform texture3D			ProbeOcclusionFine0;
layout(binding = 7) uniform texture3D			ProbeOcclusionFine1;

layout(binding = 8) uniform texture2DArray		IrradianceSHCoarse;
layout(binding = 9) uniform itexture2DArray		ProbeMetadataCoarse;
layout(binding = 10) uniform texture3D			ProbeOcclusionCoarse0;
layout(binding = 11) uniform texture3D			ProbeOcclusionCoarse1;

layout(binding = 12) uniform texture2DArray		IrradianceSHFar;
layout(binding = 13) uniform itexture2DArray	ProbeMetadataFar;
layout(binding = 14) uniform texture3D			ProbeOcclusionFar0;
layout(binding = 15) uniform texture3D			ProbeOcclusionFar1;

layout(binding = 16) uniform utexture2D			Sobol16;
layout(binding = 17) uniform utexture3D			OwenScrambling16;
layout(binding = 18) uniform utexture3D			OwenRanking16;

layout(binding = 19) uniform sampler			sampLinear;

layout(binding = 20, rgba16f) uniform image2D	SSRTGI;


float InterleavedGradientNoise( vec2 seed )
{
	vec3 magic = vec3( 0.06711056f, 0.00583715f, 52.9829189f );
	return fract( magic.z * fract(dot(seed, magic.xy)) );
}


vec3 DecodeNormal(in vec3 e) 
{
	e = e * 2.f - 1.f;
	
	vec2 temp = vec2(e.x + e.y, e.x - e.y) * 0.5;
	vec3 v = vec3(temp, 1.0 - abs(temp.x) - abs(temp.y));

	return normalize(v) * sign(e.z);
}


//-------------------------------------------
// Ray trace depth buffer
//-------------------------------------------

vec2 Clip(vec2 cIn, vec2 cMin, vec2 cMax, vec2 cM)
{
    vec2 t = 1.f.xx;

    vec2 diff = sign(cIn - cM) * max(1e-6f.xx, abs(cIn - cM));

    t = clamp(min(t, max((cMax - cM) / diff, (cMin - cM) / diff)), 0.f.xx, 1.f.xx);

    return min(t.r, t.g) * (cIn - cM) + cM;
}



vec2 ComputeCoordsLeavingCell(in vec2 TexcInCell, in vec2 CellSize, in vec2 RayDir)
{
    vec2 CellCoords = CellSize * (0.5f + floor(TexcInCell / CellSize));

    return Clip(TexcInCell + RayDir, CellCoords - CellSize * 0.5f, CellCoords + CellSize * 0.5f, TexcInCell) + RayDir * 2e-4f;
}



float ComputeRayDepth(in vec2 Texc, in vec2 TexcOrigin, in vec2 p, in vec2 r, in float scale, out float t)
{
    float alpha = 2.f * length(Texc - TexcOrigin);
    t           = alpha * p.y * p.y / (scale - (p.y * r.y) * alpha);
    float z     = (p.x + t * r.x) / (p.y + t * r.y);

    return 2.f * Near * Far / ((Far + Near) - (2.f * z - 1.f) * (Near - Far));
}



bool RayTrace(in vec3 Pos, in vec3 Dir, in vec2 Texc, in float NdotV, in uint MaxSteps, out vec2 HitTexcoords, out float RayLength, out bool occluded)
{
	occluded = false;

    vec2  PixelSize         = 1.f / textureSize(HiZ, 0).xy;

    vec4    p               = m_ViewProj * vec4(Pos, 1.f);
    vec4    r               = m_ViewProj * vec4(Dir, 0.f);
    vec2    dir             = p.w * r.xy - r.w * p.xy;
    float   scale           = length(dir);
    dir /= scale;

    vec2    u               = vec2(dir.x, -dir.y);
    uint    level           = 0U;
    uint    targetLevel     = 0U;
    vec2    cell_size       = 2.f * PixelSize.xy;

    HitTexcoords            = Texc;
    RayLength               = 0.f;

    vec2    next_texc       = ComputeCoordsLeavingCell(HitTexcoords, cell_size, u);    
    float   RayDepth        = ComputeRayDepth(next_texc, Texc, p.zw, r.zw, scale, RayLength);

    vec2    texc_out_of_higher_cell = next_texc;
    bool    bHigherCellTested       = false;

    for (uint i = 0U; i < MaxSteps; i++)
    {
        // Get the minimum depth of the geometry within the cell
        float GeomDepth = textureLod(sampler2D(HiZ, sampLinear), HitTexcoords, level).r;
        GeomDepth = 2.f * Far * Near / (Near + Far - (2.f * GeomDepth - 1.f) * (Near - Far));

        // Hit
        if (GeomDepth < RayDepth && length(HitTexcoords - Texc) > length(PixelSize))
        {
            // Final hit point
            if (level <= targetLevel)
            {
                // Is the hit point occluded by geometry ?
                float MinRayDepth = ComputeRayDepth(HitTexcoords, Texc, p.zw, r.zw, scale, RayLength);

                if (RayDepth - GeomDepth > 4.f * (RayDepth - MinRayDepth))
				{
					occluded = RayDepth - GeomDepth < 0.2f;
                    return false;
				}
                    
                // Hit point is valid
                return true;
            }

            // Check lower mip level
            cell_size /= 2.f;
            level--;

            bHigherCellTested = true;
            texc_out_of_higher_cell = next_texc;
        }

        // No hit
        else
        {
            // Go to a higher mip level if there is one
            if (level < 6 && (!bHigherCellTested || length(HitTexcoords - texc_out_of_higher_cell) < 1e-4f))
            {
                cell_size *= 2.f;
                level++;

                bHigherCellTested = false;
            }

            // Go to the outer limit of the tested cell
            HitTexcoords = next_texc;

            // Are we out of the screen ?
            if (HitTexcoords.x * (1.f - HitTexcoords.x) <= 0.f || HitTexcoords.y * (1.f - HitTexcoords.y) <= 0.f)
                return false;

            else if (RayLength > MaxRayLength)
                return false;            
        }

        // Compute the maximum depth of the ray within the cell
        next_texc   = ComputeCoordsLeavingCell(HitTexcoords, cell_size, u);
        RayDepth    = ComputeRayDepth(next_texc, Texc, p.zw, r.zw, scale, RayLength);
    }

    return false;
}


float sdBox( vec3 p, vec3 b )
{
	vec3 q = abs(p) - b;
	return length(max(q,0.0)) + min(max(q.x,max(q.y,q.z)),0.0);
}


vec3 CascadeSHGI(in vec3 pos, in vec3 dir)
{
	vec3 Center = Center0.xyz;
	vec3 Size	= Size0.xyz;

	vec3 Radiance = 0.f.xxx;

	vec3 giPos = (pos.xyz - Center.xyz) / Size.xyz + 0.5f.xxx;

	float d0 = sdBox((pos.xyz - RealCenter.xyz) / (Size.xyz * (1.f - 1.f / textureSize(ProbeMetadataFine, 0).xyz)), 0.5f.xxx); 

	if (d0 < 0.f)
		Radiance = ComputeSHRadiance(ProbeMetadataFine, IrradianceSHFine, ProbeOcclusionFine0, ProbeOcclusionFine1, sampLinear, pos, giPos, Center.xyz, Size.xyz, dir) * (1.f / 3.1415926f);

	if (d0 > -0.1f)
	{
		Center	= Center1.xyz;
		Size	= Size1.xyz;

		giPos = (pos.xyz - Center.xyz) / Size.xyz + 0.5f.xxx;
		float d1 = sdBox((pos.xyz - RealCenter.xyz) / (Size.xyz * (1.f - 1.f / textureSize(ProbeMetadataCoarse, 0).xyz)), 0.5f.xxx); 

		if (d1 < 0.f)
		{
			vec3 diffuse1 = ComputeSHRadiance(ProbeMetadataCoarse, IrradianceSHCoarse, ProbeOcclusionCoarse0, ProbeOcclusionCoarse1, sampLinear, pos, giPos, Center.xyz, Size.xyz, dir) * (1.f / 3.1415926f);

			if (d0 < 0.f)
				Radiance = mix(diffuse1, Radiance, -d0 * 10.f);

			else
				Radiance = diffuse1;
		}

		if (d1 > -0.1f)
		{
			Center	= Center2.xyz;
			Size	= Size2.xyz;

			giPos = (pos.xyz - Center.xyz) / Size.xyz + 0.5f.xxx;
			float d2 = sdBox((pos.xyz - Center.xyz) / Size.xyz, 0.5f.xxx); 

			if (d2 < 0.f)
			{
				vec3 diffuse2 = ComputeSHRadiance(ProbeMetadataFar, IrradianceSHFar, ProbeOcclusionFar0, ProbeOcclusionFar1, sampLinear, pos, giPos, Center.xyz, Size.xyz, dir) * (1.f / 3.1415926f);

				if (d1 < 0.f)
					Radiance = mix(diffuse2, Radiance, -d1 * 10.f);

				else
					Radiance = diffuse2;
			}
		}
	}		

	return Radiance;
}



float OwenScrambledSobol(uint pixel_i, uint pixel_j, uint sampleIndex, uint sampleDimension)
{
	// wrap arguments
	pixel_i = pixel_i & 127;
	pixel_j = pixel_j & 127;
	sampleIndex = sampleIndex & 255;
	sampleDimension = sampleDimension & 255;

	// xor index based on optimized ranking
	uint rankedSampleIndex = sampleIndex ^ texelFetch(OwenRanking16, ivec3(pixel_i, pixel_j, sampleDimension & 7), 0).r;

	// fetch value in sequence
	uint value = texelFetch(Sobol16, ivec2(sampleDimension, rankedSampleIndex), 0).r;

	// If the dimension is optimized, xor sequence value based on optimized scrambling
	value = value ^ texelFetch(OwenScrambling16, ivec3(pixel_i, pixel_j, sampleDimension & 7), 0).r;

	// convert to float and return
	float v = (0.5f+value)/256.0f;
	return v;
}



layout(local_size_x = 8, local_size_y = 8, local_size_z = 1) in;
void main()
{
	ivec2 size = textureSize(DepthMap, 0).xy;

	if (gl_GlobalInvocationID.x > size.x || gl_GlobalInvocationID.y > size.y)
		return;

	float depth = texelFetch(DepthMap, ivec2(gl_GlobalInvocationID.xy), 0).r;

	if (depth == 0.f)
		return;

	vec2 Texcoords = (gl_GlobalInvocationID.xy + 0.5f) / textureSize(DepthMap, 0).xy;

	vec4 pos = m_InvViewProj * vec4(Texcoords.xy * vec2(2.f, -2.f) - vec2(1.f, -1.f), depth, 1.f);
	pos /= pos.w;

	vec4 normalTex	= texelFetch(NormalMap, ivec2(gl_GlobalInvocationID.xy), 0);
	vec3 normal		= DecodeNormal(normalTex.rga);

	float alpha = 2.f * 3.141592f * InterleavedGradientNoise( gl_GlobalInvocationID.xy );

	vec2 rotation = vec2(cos(alpha), sin(alpha));

	mat3 rot = mat3(rotation.x, rotation.y, 0.f, 
					-rotation.y, rotation.x, 0.f, 
					0.f, 0.f, 1.f);

	vec3 tangent	= normalize(mix(vec3(0.f, 0.f, 1.f) - normal * normal.z, vec3(1.f, 0.f, 0.f), step(0.9f, normal.z)));
	vec3 bitangent	= cross(normal, tangent);
	mat3 tbn		= mat3(tangent, bitangent, normal) * rot;

	float AO				= 0.f;
	vec3 contactIrradiance	= 0.f.xxx;
	float w = 0.f;

	pos.xyz += 0.02f * normal;

	for (int i = 0; i < 4; i++)
	{
		vec3 dir = tbn * m_Offsets[i].xyz;

		vec2 HitTexcoord;
		float RayLength;
		float vis = 1.f;
		bool occluded = false;
		uint maxSteps = 64;

		// Ray tracing
		if (RayTrace(pos.xyz, dir, Texcoords, dot(dir, normal), maxSteps, HitTexcoord, RayLength, occluded))
		{
			vis = 0.f;
			contactIrradiance += max(0.f, dot(normal, dir)) * textureLod(sampler2D(Radiance, sampLinear), HitTexcoord, 0).rgb;
			w += max(0.f, dot(normal, dir));
		}

		else
		{
			vis = occluded ? 0.f : 1.f;
		}

		AO += vis;
	}

	AO *= 0.25f;
	contactIrradiance /= max(1e-6f, w);

	imageStore(SSRTGI, ivec2(gl_GlobalInvocationID.xy), vec4(contactIrradiance, AO));
}

