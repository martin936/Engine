#version 450
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_nonuniform_qualifier : require


#define SDF_CB_SLOT				3
#define SDF_TEX_SLOT			0
//#define VOLUME_ALBEDO_TEX_SLOT	1


#include "../../Lights/GLSL/SDF.glsl"


layout(binding = 1) uniform texture3D	IrradianceCache;

layout (binding = 4, std140) uniform cb4
{
	mat4	m_View;
	mat4	m_Proj;
	mat4	m_ViewProj;
	mat4	m_InvView;
	mat4	m_InvViewProj;

	mat4	m_LastView;
	mat4	m_LastProj;
	mat4	m_LastViewProj;
	mat4	m_LastInvView;
	mat4	m_LastInvViewProj;

	vec4	m_Eye;
};


layout(binding = 2) uniform sampler			sampLinear;


layout(binding = 5, rgba16f) uniform writeonly image2D Color;


layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main( void )
{
	vec3 pos;

	vec2 screenSize		= imageSize(Color).xy;
	vec2 texCoords		= (gl_GlobalInvocationID.xy + 0.5f) / screenSize;
	texCoords.y = 1.f - texCoords.y;

	float linearRoughness = 0.5f;
	float roughness = linearRoughness * linearRoughness;

	vec4 p	= m_InvViewProj * vec4(2.f * texCoords - 1.f, 0.5f, 1.f);
	p /= p.w;
	
	vec3 view = normalize(p.xyz - m_Eye.xyz);

	bool hit = RayMarchSDF(sampLinear, m_Eye.xyz, view, pos);

	if (!hit)
	{
		imageStore(Color, ivec2(gl_GlobalInvocationID.xy), 0.f.xxxx);
		return;
	}

	p = m_ViewProj * vec4(pos, 1.f);
	float depth = p.z / p.w;

	vec3 normal = normalize(SDFGradient(sampLinear, pos));
	//
	//float check = dot(normal, 1.f.xxx);
	//
	//if (isnan(check) || isinf(check))
	//	return;

	//vec3 color = albedo.rgb * (Diffuse + Emissive);
	//vec3 color = normal * 0.5f + 0.5f;
	vec3 coords = Pos2Coords(pos);
	vec4 irradiance = textureLod(sampler3D(IrradianceCache, sampLinear), coords, 0.f);
	irradiance.rgb /= max(1e-3f, irradiance.w);

	imageStore(Color, ivec2(gl_GlobalInvocationID.xy), vec4(normal.rgb * 0.5f + 0.5f, 0.f));
}
