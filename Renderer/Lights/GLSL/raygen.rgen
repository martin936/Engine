#version 460
#extension GL_GOOGLE_include_directive : require
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_samplerless_texture_functions : require

layout(binding = 8) uniform utexture2D SobolSequence;
layout(binding = 9) uniform utexture3D OwenScrambling;
layout(binding = 10) uniform utexture3D OwenRanking;

struct Hit 
{
    vec3 position;
    vec3 normal;
};

struct Ray_Payload 
{
    Hit  hit;
    uint color;
};

vec4 ToRGBE(vec3 inColor)
{
    float base = max(inColor.r, max(inColor.g, inColor.b));
    int e;
    float m = frexp(base, e);
    return vec4(clamp(inColor.rgb / exp2(e), 0.f.xxx, 1.f.xxx), e + 127);
}

vec3 FromRGBE(vec4 inColor)
{
    return inColor.rgb * exp2(inColor.a - 127);
}


vec3 UnpackRGBE(uint packedInput)
{
    vec4 unpackedOutput;
    uvec4 p = uvec4((packedInput & 0xFFU),
		(packedInput >> 8U) & 0xFFU,
		(packedInput >> 16U) & 0xFFU,
		(packedInput >> 24U));

    unpackedOutput = vec4(p) / vec4(255, 255, 255, 1.0f);
    return FromRGBE(unpackedOutput);
}


uint PackRGBE(vec3 unpackedInput)
{
    uvec4 u = uvec4(ToRGBE(unpackedInput) * vec4(255, 255, 255, 1.0f));
    uint packedOutput = (u.w << 24U) | (u.z << 16U) | (u.y << 8U) | u.x;
    return packedOutput;
}

struct Ray 
{
    vec3 origin;
    vec3 dir;
};

layout(binding = 0) uniform accelerationStructureEXT accel;

layout(binding = 1, rgba16f) uniform image2D Output;

layout (binding = 2, std140) uniform cb2
{
	mat4	m_View;
	mat4	m_Proj;
	mat4	m_ViewProj;
	mat4	m_InvView;
	mat4	m_InvViewProj;

	mat4	m_LastView;
	mat4	m_LastProj;
	mat4	m_LastViewProj;
	mat4	m_LastInvView;
	mat4	m_LastInvViewProj;

	vec4	m_Eye;
};


layout (binding = 11, std140) uniform cb11
{
    uint seed;
    uvec3 padding;
};


layout(location = 0) rayPayloadEXT Ray_Payload payload;

const float tmin = 1e-3f;
const float tmax = 1e+3f;

vec3 get_direction(vec2 film_position) 
{
    const float tan_fovy_over_2 = 0.414; // tan(45/2)

    vec2 uv = 2.0 * (film_position / vec2(gl_LaunchSizeEXT.xy)) - 1.0;
    float aspect_ratio = float(gl_LaunchSizeEXT.x) / float(gl_LaunchSizeEXT.y);

    float dir_x =  uv.x *  aspect_ratio * tan_fovy_over_2;
    float dir_y = -uv.y * tan_fovy_over_2;
    return normalize(vec3(dir_x, dir_y, -1.f));
}

Ray generate_ray(mat4 camera_to_world, vec2 film_position) 
{
    Ray ray;

    vec2 texcoords = film_position.xy / imageSize(Output).xy;
    texcoords.y = 1.f - texcoords.y;
    texcoords = texcoords * 2.f - 1.f;

    vec4 target     = m_InvViewProj * vec4(texcoords.x, texcoords.y, 1, 1);
    target /= target.w;

    ray.origin      = m_Eye.xyz;
    ray.dir         = normalize(target.xyz - m_Eye.xyz);
    return ray;
}


vec3 UniformSampleHemisphere(vec3 N, vec2 u)
{
    float theta     = 2.f * 3.1415926f * u.x;
    float cos_phi   = 1.f - 2.f * u.y;
    float sin_phi   = sqrt(max(0.f, 1.f - cos_phi * cos_phi));
    
    vec3 dir;
    dir.x = sin_phi * cos(theta);
    dir.y = sin_phi * sin(theta);
    dir.z = cos_phi;

    vec3 Upfloattor = abs(N.z) < 0.999 ? vec3(0, 0, 1) : vec3(1, 0, 0);
    vec3 TangentX = normalize(cross(Upfloattor, N));
    vec3 TangentY = cross(N, TangentX);

    // Tangent to world space
    return TangentX * dir.x + TangentY * dir.y + N * dir.z;
}


float OwenScrambledSobol(uint pixel_i, uint pixel_j, uint sampleIndex, uint sampleDimension)
{
	// wrap arguments
	pixel_i = pixel_i & 127;
	pixel_j = pixel_j & 127;
	sampleIndex = sampleIndex & 255;
	sampleDimension = sampleDimension & 255;

	// xor index based on optimized ranking
	uint rankedSampleIndex = sampleIndex ^ texelFetch(OwenRanking, ivec3(pixel_i, pixel_j, sampleDimension & 7), 0).r;

	// fetch value in sequence
	uint value = texelFetch(SobolSequence, ivec2(sampleDimension, rankedSampleIndex), 0).r;

	// If the dimension is optimized, xor sequence value based on optimized scrambling
	value = value ^ texelFetch(OwenScrambling, ivec3(pixel_i, pixel_j, sampleDimension & 7), 0).r;

	// convert to float and return
	float v = (0.5f+value)/256.0f;
	return v;
}


vec3 trace_ray(vec2 sample_pos) 
{
    vec3 sum = 0.f.xxx;

    uint numSamples = 16;
    uint maxBounces = 5;

    for (uint s = 0; s < numSamples; s++)
    {
        vec3 color = 1.f.xxx;

        Ray ray = generate_ray(m_ViewProj, sample_pos);

        for (uint i = 0; i < maxBounces; i++)
        {
            traceRayEXT(accel, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, ray.origin, tmin, ray.dir, tmax, 0);

            color *= UnpackRGBE(payload.color);

            if (dot(abs(payload.hit.normal), 1.f.xxx) != 0.f)
            {
                vec2 u;
                u.x = OwenScrambledSobol(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, seed + s, i * 2 + 0);
                u.y = OwenScrambledSobol(gl_LaunchIDEXT.x, gl_LaunchIDEXT.y, seed + s, i * 2 + 1);

                ray.dir     = normalize(UniformSampleHemisphere(payload.hit.normal, u));
                ray.origin  = payload.hit.position + 1e-6f * ray.dir;
            }

            else
                break;
        }

        sum += color;
    }

    return sum * (1.f / 32.f);
}

void main() 
{
    const vec2 sample_origin = vec2(gl_LaunchIDEXT.xy);
    vec3 color = vec3(0);

    color = trace_ray(sample_origin + vec2(0.5));

    imageStore(Output, ivec2(gl_LaunchIDEXT.xy), vec4(color, 1.0));
}
