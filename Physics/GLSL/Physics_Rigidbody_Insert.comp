#version 450

struct Particle
{
	vec3	Pos;
	uint	objectId;

	vec3	Velocity;
	float	Mass;
};


struct Rigidbody
{
	vec3	CenterOfMass;
	uint	NumParticles;

	vec3	LinearMomentum;
	float	Mass;

	vec4	AngularMomentum;
	vec4	Rotation;

	vec3	NewCenterOfMass;
	mat3	ShapeMatchingRotation;
};


layout(binding = 0, std430) buffer restrict writeonly buf1
{
	vec4	particleInit[];
};


layout(binding = 1, std430) buffer restrict writeonly buf2
{
	Particle	particles[];
};


layout(binding = 2, r32ui)	uniform restrict readonly uimage3D	Voxels;


layout(binding = 3, std430) buffer restrict writeonly buf3
{
	Rigidbody	solids[];
};


layout(push_constant) uniform pc0
{
	vec3	Center;
	float	Mass;

	vec3	Size;
	uint	StartOffset;

	vec3	CenterOfMass;
	uint	objectId;

	vec3	unused;
	uint	numParticles;
};


layout(local_size_x = 8, local_size_y = 8, local_size_z = 8) in;
void main() 
{
	ivec3 size = imageSize(Voxels).xyz;

	if (gl_GlobalInvocationID.x == 0)
	{
		solids[objectId].CenterOfMass			= CenterOfMass;
		solids[objectId].NewCenterOfMass		= 0.f.xxx;
		solids[objectId].NumParticles			= numParticles;
		solids[objectId].LinearMomentum			= 0.f.xxx;
		solids[objectId].Mass					= Mass;
		solids[objectId].AngularMomentum		= 0.f.xxxx;
		solids[objectId].Rotation				= vec4(0.f.xxx, 1.f);
		solids[objectId].ShapeMatchingRotation	= mat3(0.f);
	}

	if (gl_GlobalInvocationID.x < size.x && gl_GlobalInvocationID.y < size.y && gl_GlobalInvocationID.z < size.z)
	{
		uint index = imageLoad(Voxels, ivec3(gl_GlobalInvocationID.xyz)).x;

		if (index > 0u)
		{
			index = StartOffset + index - 1;

			vec3 coords = (gl_GlobalInvocationID.xyz + 0.5f) / size;
			vec3 pos	= (coords - 0.5f) * Size + Center;

			particles[index].Pos		= pos;
			particles[index].objectId	= objectId;
			particles[index].Velocity	= 0.f.xxx;
			particles[index].Mass		= Mass / numParticles;

			particleInit[index]			= vec4(pos - CenterOfMass, 0.f);
		}
	}
}
